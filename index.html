<!DOCTYPE html>
<meta charset="utf-8">
<head>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:300,600,700' rel='stylesheet' type='text/css'>
<link href="css/tipsy.css" rel="stylesheet" type="text/css" /> 
	</head>
	<style>
	body{
		font-family: "Open Sans",'sans-serif';
	}

.surroundingPoints rect.selected{
opacity: .1;
}
/* Hoverbox */
#hoverbox {
	/*outline:1px solid grey;*/
	width:20%; 
	height:100%; 
	right: 4px; 
	overflow:auto;
	position: fixed;
}

#hoverbox.hidden {
  /*display: none;*/
}
#hoverbox .title {
  fill: white;
  text-transform: uppercase;
}
.listBooks {
	border-bottom: 1px solid lightgray;
	display: block;
	padding:14px;
	  cursor: pointer;
}
#hoverbox rect.background {
  fill: black;
  opacity: 0.2;
}
.outText{
	font-size: 12px; font-size:12pt; position: absolute; padding: 5px; z-index: 100000; 
	background-color: #000; 
	color: #FFF; max-width: 300px; padding: 5px 8px 4px 8px; text-align: center; 
}
.mouseoverText{
	font-size: 10px; 
}
.subjectText{
	text-transform:uppercase;
	font-size: 9px;
}
.outerCircleText{
border-radius: 4px 4px 4px 4px;
-moz-border-radius: 4px 4px 4px 4px;
-webkit-border-radius: 4px 4px 4px 4px;
border: 0.5px solid #808080;
}
</style>
<script type="text/javascript" src="js/lib/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="js/lib/jquery.tipsy.js"></script>
<script type="text/javascript" src="js/lib/d3.v3.js"></script>
<script type="text/javascript" src="js/lib/jquery.hoverIntent.js"></script>
<body>
		<!-- <div id = "hoverbox"></div> -->
<div class = "outerCircleText"></div>
	<div id = "hoverbox"></div>
<script type = "text/javascript">

//NEXT THING IS CLICKING TO GET TO THE BOOKS HTML LINK

var freqscale = 5; //size of circles
var  MAX_LEVELS = 10; //number larger than number of levels of circles
var radius_levels = [0, 0, 240, 180, 125, 70, 15, 0, 0, 0]; //how far away from the center each level is
var subradius = 250; 
var MIN_LINE = 3.0; //length of the little ones
var TEXT_PAD_X = 5;
var TEXT_PAD_Y = 2;
var LEGEND_X_MARGIN = 20;
var LEGEND_SCALE = 0.003;

//  Make an array of Subjects
var subjects;
//  Make an array of Connections
var connections;

var bcolor;
var subtext;
var hsubtext;
var concolor;
var hconcolor;
var legendconcolor;
  bcolor = "rgba(0, 0, 0, 255)";
  concolor = "rgba(210, 210, 210, 50)";
  hconcolor = "rgba(210, 210, 210, 100)";
  legendconcolor = "rgba(210, 210, 210, 75)";
  subtext = "rgba(150, 150, 150, 255)";
  hsubtext = "rgba(210, 210, 210, 255)";
loadBooks();

var boolSelected = 0;
var margin = {top: 20, right: 20, bottom: 30, left: 50},
	width = 1280, //- margin.left - margin.right,
	height = 750; //- margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
.attr("width",width)
.attr("height",height);
	// .attr("width", width + margin.left + margin.right)
	// .attr("height", height*2 + margin.top + margin.bottom);
		// .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var subjX=[];
var subjY=[];
var subjText=[];
var sData = [];
var subjCode = [];
var subjTextInside = [];
var subjLoc = [];

// var color = d3.scale.category20c();

var rScale = d3.scale.linear()
  .domain([-7, 7]) 
  .range([-180, 180]);

var freqIs=[];
var item;

var subradius = 300;

var firstLoad = -1;
var tigReggib = -1;
var clicked = 0;
// runInnerCircles();
// runOuterCircles();
var checkedIt = [];
var wasItSubj;
var storeClicks = {};
function runOuterCircles(){
//BUT HAVING ASYNCHORNOUS PROBLEMS FOR LOADING THE ARRAYS SO IS THERE SOME SORT OF WHEN YOURE FINISHED DO THE OTHER THING THING?
////this works great
d3.tsv("subjects_top25.tsv", function(error, data) {
var jump = Math.PI*2/data.length; //    float jump = TWO_PI/(float
var angle = 0;

	// .on("mouseover", function(d){
	// 	if (d.subjCode>4){
	// 	item = d.subjCode-5;
	// 	}
	// 	else {
	// 	item = d.subjCode;
	// 	}
	// 	// item = d.subjCode;
	// })
	// .on("mouseout", function(d){
	// 	removeLines();
	// });

// $('.surroundingCircles').hoverIntent({
// 	over: function(){
// 		// runLines(item);
// 	},
// 	out: function(){
// 		// removeLines();
// 	}
//   })



var text = svg.selectAll('.subjectText')
	.data(data)
	.enter().append("text")
	.attr("class",function(d,i){
		subjCode.push(d.subjCode);
		freqIs.push(d.freq);
		subjLoc.push(d.loc);
		subjTextInside.push(d.subject);
		subjX.push(width*.5+subradius*Math.cos(jump*(d.loc-1)));
		subjY.push(height*.5+subradius*Math.sin(jump*(d.loc-1))); 
		return "subjectText"; 
	})
	.attr("x", function(d,i){ 
		if (subjX[i]>width/2){
				return subjX[i]; 	
		}
		else {
			return subjX[i]-d.subject.length*3;
		}
	})
	.attr("y", function(d,i){ 
		return subjY[i]; 
	})
	.text(function(d,i) { 
		return d.subject; 
	})
	.attr("fill",function(d,i){
		if (d.loc<=6){
			return "teal";
		}
		if (d.loc>6&&d.loc<=10){
			return "lightgreen";
		}
		if (d.loc>10&&d.loc<=15){
			return "lightblue";
		}
		if (d.loc>15&&d.loc<21){
			return "blue";
		}
	})	
	.attr("opacity",1)
	.each(function(d) {
        d.width = this.getBBox().width;
      })
	.on("click", function(d,i){
		var d = this.__data__;
		wasItSubj = d.subjCode;

		storeClicks[i] = storeClicks[i] ? storeClicks[i]+1 : 1; //now this is counters

		if(storeClicks[i]%2==1){ //if clicked ON
			console.log("clicked on"+storeClicks[i]%2)
			d3.select(this)
			.transition()
			.attr("fill","yellow");
			runLines(d.subjCode);
			checkedIt.push(d.subjCode);
			checked(checkedIt);
		}

		if(storeClicks[i]%2==0){ //if unselected
			console.log("clicked off"+storeClicks[i]%2)

			d3.select(this)
			.transition()
			.attr("fill","black");

		//and remove that subject number
		for (c=0; c<checkedIt.length; c++){
			if (checkedIt[c]==d.subjCode){
				console.log(checkedIt+"before removing");
				checkedIt.splice(c,1);
				console.log(checkedIt+"after removing");
			}
		}
		checked(checkedIt);
		removeRunnedLines(d.subjCode);
		d3.selectAll(".mouseoverText").remove();

		// d3.selectAll('.checkedLinesOut').remove(); 
		// if (checkedIt.length<1){
		// 	console.log("remove checked lines even if subject is just 1")
		// 	d3.selectAll('.checkedLines').remove();
		// 	d3.selectAll('.linesIn').remove();
			d3.selectAll("circle.inCircle"+i)
				.transition()
				.attr("opacity", ".1")
				.attr("fill","grey");
		// }	
		}
	});

var surroundingRects = svg.selectAll("surroundingPoints")
	.data(data)
	.enter().append("rect")
	.attr("class", "surroundingPoints")
	.attr("x", function(d,i){
		if (subjX[i]>width/2){
				return subjX[i]-5; 	
		}
		else {
			return subjX[i]-(d.subject.length*3)-5;
		}
	})
	.attr("y", function(d,i){  
			return height*.5+subradius*Math.sin(jump*(d.loc-1))-10;
	})
	.attr("width", function(d){ 
		return d.width+10;
	})
	.attr("height", 14)
	.attr("opacity",.5)
	.attr("fill","none")
	.attr("stroke", function(d,i){
		if (d.loc<=6){
			return "teal";
		}
		if (d.loc>6&&d.loc<=10){
			return "lightgreen";
		}
		if (d.loc>10&&d.loc<=15){
			return "lightblue";
		}
		if (d.loc>15&&d.loc<21){
			return "blue";
		}
	});


$('.subjectText').tipsy({ 
		gravity: 'nw', 
		html: true, 
		title: function() {
		  var d = this.__data__;
		  return "frequency: "+d.freq;

		}
});
})
}

//Move SVG elements to the end of their container,
//so they appear "on top".
var moveToFront = function() { 
	this.parentNode.appendChild(this); 
}

var angles = [];
var first = [];
var r = [];
var calcX=[];
var calcY=[];
var radiusIs = [];
var allCodes = [];	
var temp = [];
var thisThing;
var whatRadius = [];
var myVar;
var firstLoadVar;
var secondLoadVar;
var ready = 0;

var connDataLength;
firstVariable();
function firstVariable(){
	d3.tsv("connectionfreqcodes_top25.txt", function(error, cData) {
		connDataLength = cData.length;
	})
}
////PROBLEM OF GETTING THIS VARIABLE BEFORE RUNNING OTHER FUNCTIONS
firstLoadVar = setInterval(function(){ 
	if (connDataLength>0){
	if (firstLoad<connDataLength-1){
	d3.tsv("connectionfreqcodes_top25.txt", function(error, cData) {
	firstLoad++; 
	if (firstLoad>=0){
	storeInnerSubjs(cData[firstLoad].codeName, firstLoad);		
	}
	})
	}
	else {
	runOnce();
	clearInterval(firstLoadVar);
	}
}
},1);	

function runOnce(){
	runInnerCircles();
	runOuterCircles();	
}

function runInnerCircles(){

d3.tsv("connectionfreqcodes_top25.txt", function(error, cData) {
for (i = 0; i < cData.length;i++) {
	allCodes.push(cData[i].codeName);
	angles.push(holdAngles[i]);
	radiusIs.push(radius_levels[storeLengths[i]]);
}

for (i=0; i<allCodes.length; i++){
	first.push(allCodes[i].split(","));
	// if (first)
	r.push(allCodes[i].split(","));
}

var inCircle = svg.selectAll("inCircle")
	.data(cData)
	.enter().append("circle")
	.attr("class", function(d,i){ return "inCircle"+i; })
	.attr("cx", function(d,i){
		calcX.push(width*0.5+radiusIs[i]*Math.cos(angles[i]));
		return width*0.5+radiusIs[i]*Math.cos(angles[i]);
	})
	.attr("cy", function(d,i){ 
		calcY.push(height*0.5+radiusIs[i]*Math.sin(angles[i]));
		return height*0.5+radiusIs[i]*Math.sin(angles[i]);
	})
	.attr("r", function(d){
		whatRadius.push(Math.log(d.freq+2.0)*freqscale/2);
		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill", "gray")
	.attr("opacity",.1)
	.attr("stroke","darkgray")
	.attr("stroke-width",1)
	.on("mouseover", function(d,i){
		d3.select(this)
		.attr("opacity", .9);
		console.log(d.codeName+"sending to all out");
		index = i;
		allOut(d.codeName, index); //FIX WHAT THING IS NOW
		})
	.on("click", function(d,i){
		console.log("clicked for books")
		d3.select(this)
		console.log(d.codeName+"d.codeName on click")
		books(d.codeName,i); //FIX CODENAME
		})
	.on("mouseout", function(d,i){
		d3.select(this)
		.attr("opacity", .1);
		removeOutwardLines(d.codeName, i); //FIX CODENAME
	})
makeGlyph();    

function makeGlyph(){
myVar = setInterval(function(){ 
if (tigReggib<connDataLength-1){
	tigReggib++; 
	runLinesOut(cData[tigReggib].codeName, tigReggib); //FIX CODENAME
}
else {}
},1);
if (tigReggib>=connDataLength-1){
	clearInterval(myVar);
}
}
})
}

var thisIs = [];
var otherThis = [];
var storeLengths = [];
var countLengths = {};
var jumps = {};
var anglesAre = [];
var holdAngles = [];

var countIt = 0;
var thisCircle;
function storeInnerSubjs(arrayOfSubjs, index){

otherThis = arrayOfSubjs.split(",");
storeLengths.push(otherThis.length); //now this is "q"

countLengths[otherThis.length] = countLengths[otherThis.length] ? countLengths[otherThis.length]+1 : 1; //now this is counters

checkLengths(otherThis,index); //here we finish counters array and create the new jumps thing
}
var stop;
function checkLengths(otherThis,index){
for (i=0; i<MAX_LEVELS; i++){
	anglesAre[i] = 0;

if (countLengths[i]===undefined){
	console.log("undefined");
	countLengths[i] = 0;
}
else {}
	jumps[i]=((Math.PI*2)/countLengths[i]);
}
if (index==connDataLength-1){
	console.log(connDataLength);
	newFunction();
}
}
function newFunction(){
	var onlyThis = 3;
	console.log(jumps[3]);
	for (i=0; i<storeLengths.length; i++){
		anglesAre[storeLengths[i]]+=jumps[storeLengths[i]];
		holdAngles.push(anglesAre[storeLengths[i]]);
	}	
}

// function removeLines(){
// svg.selectAll(".linesIn") //could be just .remove()
	// .transition()
	// .attr("stroke-opacity",.07)
// }
var theseNums = [];
var boolUnselect = 0;

function checked(checkedIt){

boolUnselect = 1;
console.log(checkedIt+"checked");

theseNums = checkedIt;

		// if (checkedIt.length>1){
			// d3.selectAll('.linesIn').transition().duration(2000).attr("stroke-opacity",.2);
			 // .attr("stroke-width",.5);
		// }

var chckdLines = svg.selectAll("checkedLines")
	.data(r)
	.enter()
	.append("l")
	.attr("class", function(d,i){
		var newThing = [];
		for (j=0; j<allCodes[i].length; j++){
			if (d[j]<5){
				newThing.push(1);
			}
			if (d[j]>=5){
				newThing.push(d[j]);
			}
		}
		newThing.sort(function(a, b){return a-b});
		theseNums.sort(function(a, b){return a-b});

			if (theseNums.toString()==newThing.toString()){
				console.log("yup in here")
				// d3.selectAll('.linesIn')
				// .transition()
				// .duration(2000)
				// .attr("opacity",.2);

				console.log(i+"this is index?");
				d3.select("circle.inCircle"+i)
				.transition()
				.attr("opacity", ".9")
				.attr("fill","yellow");
				console.log(checkedIt+"and i"+i)
				checkedIn(checkedIt, i); //FIX WHAT THING IS NOW
			}
			else {
				// console.log("wasn't equal")
				d3.select("circle.inCircle"+i)
				.transition()
				.attr("fill", "gray")
				.attr("opacity",.1);
			}
		return "checkedLines";
	})
}


var linesInG;
function runLines(passSubjNum){
console.log(passSubjNum+"running lines");
var thisNum = passSubjNum;

linesInG = svg.selectAll("linesIn")
	.data(r)
	.enter()
	.append("line")
	.attr("transform", function(d,i){
		return "translate(" + (calcX[i]) + "," + (calcY[i]) + ")";
	})
	.attr("class", function(d,i){
		var newThing = [];
		for (j=0; j<allCodes[i].length; j++){
			if (d[j]<5){
				newThing.push(1);
			}
			if (d[j]>=5){
				newThing.push(d[j]);
			}
		}
		for (n=0; n<newThing.length; n++){
			if (thisNum==newThing[n]){
			for (k=0; k<=subjCode.length; k++){
				if(subjCode[k]==thisNum){
				return "linesIn"+subjCode[k];
			}
		}
		}				
		}
	})
	.attr("x1",0)
	.attr("y1",0)
	.attr("x2",function(d,i){
		var newThing = [];
		for (j=0; j<allCodes[i].length; j++){
			if (d[j]<5){
				newThing.push(1);
			}
			if (d[j]>=5){
				newThing.push(d[j]);
			}
		}
		for (n=0; n<newThing.length; n++){
			if (thisNum==newThing[n]){
				console.log(newThing[n]+" "+thisNum+"matching?")
			for (k=0; k<=subjCode.length; k++){
				if(subjCode[k]==thisNum){
				return subjX[k]-calcX[i];
			}
			}
			}				
		}
	})
	.attr("y2",function(d,i){
		var newThing = [];
		for (j=0; j<allCodes[i].length; j++){
			if (d[j]<5){
				newThing.push(1);
			}
			if (d[j]>=5){
				newThing.push(d[j]);
			}
		}
		for (n=0; n<newThing.length; n++){
			if (thisNum==newThing[n]){
			for (k=0; k<=subjCode.length; k++){
				if(subjCode[k]==thisNum){
				return subjY[k]-calcY[i];
			}
			}
			}				
		}
	})

	.attr("stroke",function(d,i){
		return "lightpink";
	})
	.attr("opacity",.1)
	.attr("stroke-width",2);
}

//NEED TO FIGURE OUT A WAY TO TAKE OUT THAT FIRST SUBJECT LINE...
function removeRunnedLines(passSubjNum){
console.log(passSubjNum+"removing runned lines");
var thisNum = passSubjNum;
d3.selectAll(".linesIn"+passSubjNum)
	.transition()
	// .attr("opacity",0)
	.attr("x2",function(d,i){
		var newThing = [];
		for (j=0; j<allCodes[i].length; j++){
			if (d[j]<5){
				newThing.push(1);
			}
			if (d[j]>=5){
				newThing.push(d[j]);
			}
		}
		for (n=0; n<newThing.length; n++){
			if (thisNum==newThing[n]){
				console.log("equal")
				return 0;
			}				
		}
	})
	.attr("y2",function(d,i){
		var newThing = [];
		for (j=0; j<allCodes[i].length; j++){
			if (d[j]<5){
				newThing.push(1);
			}
			if (d[j]>=5){
				newThing.push(d[j]);
			}
		}
		// console.log(newThing+"in y")
		for (n=0; n<newThing.length; n++){
			if (thisNum==newThing[n]){
				return 0;
			}				
		}
	})
}


function runLinesOut(arrayOfSubjs, index){

thisIs = arrayOfSubjs.split(",");

thisCircle = index;
var justOne = thisIs[0];
var grabIt = [];
var newG = svg.selectAll("linesOut")
	.data(thisIs)
	.enter()
	.append("line")
	.attr("transform", function(d,i){
		return "translate(" + (calcX[thisCircle]) + "," + (calcY[thisCircle]) + ")";
	})
	.attr("class", "hey"+thisCircle)//"linesOut")
	.attr("x1", 0)
	.attr("y1",0)
	.attr("x2",0)
	.attr("y2",0)
	.attr("stroke",function(d,i){
		return "lightgray";
	})
	.attr("stroke-width",1);
	d3.selectAll("line.hey"+thisCircle)
		.transition()
		.attr("x2",function(d,i){
			if (d<5){
				d = 1;
			}
			else if (d>=5){
				d = d;
			}			
			for (k=1; k<=subjCode.length; k++){
				if (k==d){ ////D - ATTENTION SUBJECT CODE
						// console.log(d+"inside k"+" and i "+i)
					return (subjX[k-1]-calcX[thisCircle])/(300/whatRadius[thisCircle]);
				}
			}
		})
		.attr("y2",function(d){
					if (d<5){
						d = 1;
					}
					else if (d>=5){
						d = d;
					}	
// console.log(d+"d after minus 5");
			for (k=1; k<=subjCode.length; k++){
					if (k==d){////D - ATTENTION SUBJECT CODE
						return (subjY[k-1]-calcY[thisCircle])/(300/whatRadius[thisCircle]);
					}
				}
		})
}


var newG;
function checkedIn(arrayOfSubjs, index){
// if (checked=1){
	thisIs = arrayOfSubjs;
	// console.log(thisIs+"is checked?"+checked)
// }
thisCircle = index;
console.log(thisIs+"checkedIn")
var justOne = thisIs[0];
var grabIt = [];
var mouseText = svg.selectAll("mouseoverText")
	.data(thisIs)
	.enter()
	.append("text")
	.attr("class","mouseoverText")
	.attr("transform", function(d,i){
		return "translate(" + (calcX[thisCircle]+8) + "," + (calcY[thisCircle]-5) + ")";
	})
	.attr("fill","gray")
	.text(thisIs.length);

// newG = svg.selectAll("linesOut")
newG = svg.selectAll("checkedLinesOut")
	.data(thisIs)
	.enter()
	.append("line")
	.attr("transform", function(d,i){
		return "translate(" + (calcX[thisCircle]) + "," + (calcY[thisCircle]) + ")";
	})
	.attr("class","checkedLinesOut")
	.attr("opacity",1)
	.attr("x1", 0)
	.attr("y1",0)
	.attr("x2",function(d,i){
			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
					return subjX[k]-calcX[thisCircle];
				}
			}
	})
	.attr("y2",function(d,i){
			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
					return subjY[k]-calcY[thisCircle];
				}
			}
		})
	.attr("stroke",function(d,i){
		var whichLoc;
			for (k=1; k<=subjCode.length; k++){
				if (subjCode[k]==d){
				whichLoc = subjLoc[k];
				// console.log(whichLoc+"whichLoc all out")
				if (whichLoc<=6){
					return "teal";
				}
				if (whichLoc>6&&whichLoc<=10){
					return "lightgreen";
				}
				if (whichLoc>10&&whichLoc<=15){
					return "lightblue";
				}
				if (whichLoc>15&&whichLoc<21){
					return "blue";
				}	
			}	
		}
	})
	.attr("stroke-width",1);
}

function allOut(arrayOfSubjs, index){
// if (checked=1){
// 	thisIs = arrayOfSubjs;
// 	console.log(thisIs+"is checked?"+checked)
// }
// if (checked = 0){}
thisIs = arrayOfSubjs.split(",");

thisCircle = index;

var justOne = thisIs[0];
var grabIt = [];
var mouseText = svg.selectAll("mouseoverText")
	.data(thisIs)
	.enter()
	.append("text")
	.attr("class","mouseoverText")
	.attr("transform", function(d,i){
		return "translate(" + (calcX[thisCircle]+6) + "," + (calcY[thisCircle]-5) + ")";
	})
	.attr("fill","black")
	.text(thisIs.length);

var newG = svg.selectAll("linesOut")
	.data(thisIs)
	.enter()
	.append("line")
	.attr("class", "hey"+thisCircle)//"linesOut")
	.attr("transform", function(d,i){
		return "translate(" + (calcX[thisCircle]) + "," + (calcY[thisCircle]) + ")";
	})
	.attr("x1", 0)
	.attr("y1",0)
	.attr("x2",function(d,i){
		console.log(d+"d before all out processing");
					if (d<5){
						d = 1;
					}
					else if (d>=5){
						d = d;
					}	
		console.log(d+"d after all out processing");

			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
					console.log(d+subjCode[k]+"matched")
					// console.log(subjTextInside[k-1]+"subjText");
					return subjX[k]-calcX[thisCircle];
				}
			}
	})
	.attr("y2",function(d,i){
					if (d<5){
						d = 1;
					}
					else if (d>=5){
						d = d;
					}	

			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
					console.log(d+"in all out")
					return subjY[k]-calcY[thisCircle];
				}
			}
		})
	.attr("stroke",function(d,i){
					if (d<5){
						d = 1;
					}
					else if (d>=5){
						d = d;
					}	

		var whichLoc;
			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
				whichLoc = subjLoc[k];
				console.log(subjCode[k]+"subj code all out")
				if (whichLoc<=6){
					return "teal";
				}
				if (whichLoc>6&&whichLoc<=10){
					return "lightgreen";
				}
				if (whichLoc>10&&whichLoc<=15){
					return "lightblue";
				}
				if (whichLoc>15&&whichLoc<21){
					return "blue";
				}	
			}	
		}
	})
	.attr("stroke-width",1);
}
function removeOutwardLines(codes, thisCirc){
var outToText = svg.selectAll("outText") //not outText
d3.selectAll(".outText").remove();
	// .attr("class","mouseoverText")
d3.selectAll(".mouseoverText").remove();

console.log(thisCirc+"thisCirc");
		d3.selectAll(".hey"+thisCirc) //associated lines
		.transition()
	.attr("x2",function(d,i){
			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
					return (subjX[k]-calcX[thisCircle])/(300/whatRadius[thisCirc]);
				}
			}
	})
	.attr("y2",function(d,i){
			for (k=0; k<=subjCode.length; k++){
				if (subjCode[k]==d){
					return (subjY[k]-calcY[thisCircle])/(300/whatRadius[thisCirc]);
				}
			}
		})
	// .attr("x2",function(d,i){
	// 				if (d<5){
	// 					d = 1;
	// 				}
	// 				else if (d>=5){
	// 					d = d;
	// 				}	
	// 		for (k=0; k<=subjCode.length; k++){
	// 			if (subjCode[k]==d){
	// 				console.log(d+"remove outward and k is "+k)
	// 				return subjX[k]-calcX[thisCirc]/(300/whatRadius[thisCirc]);
	// 			}
	// 		}
	// })
	// .attr("y2",function(d,i){
	// 				if (d<5){
	// 					d = 1;
	// 				}
	// 				else if (d>=5){
	// 					d = d;
	// 				}	

	// 		for (k=0; k<=subjCode.length; k++){
	// 			if (subjCode[k]==d){
	// 				return subjY[k]-calcY[thisCirc]/(300/whatRadius[thisCirc]);
	// 			}
	// 		}
	// 	})
					// if (k==d){
					// 	return (subjX[k-1]-calcX[thisCirc])/(300/whatRadius[thisCirc]);
					// }
				// }
		// })
		// .attr("y2",function(d){
		// 			if (d<5){
		// 				d = 1;
		// 			}
		// 			else if (d>=5){
		// 				d = d;
		// 			}	
		// 	for (k=0; k<=subjCode.length; k++){
		// 		if (subjCode[k]==d){
		// 			return subjY[k]-calcY[thisCircle]/(300/whatRadius[thisCirc]);
		// 		}
		// 	}
	// .attr("y2",function(d,i){
	// 				if (d<5){
	// 					d = 1;
	// 				}
	// 				else if (d>=5){
	// 					d = d;
	// 				}	

	// 		for (k=0; k<=subjCode.length; k++){
	// 			if (subjCode[k]==d){
	// 				return subjY[k]-calcY[thisCirc]/(300);
	// 			}
	// 		}
	// 	})
				// for (k=1; k<=subjCode.length; k++){
				// 	if (k==d){
				// 		return (subjY[k-1]-calcY[thisCirc])/(300/whatRadius[thisCirc]);
				// 	}
				// }
		// })
}

var incomingIs = [];
var whichBooks = [];
var manyBooks = [];
var manyIds = [];
var manyCodes = [];

var saveId = [];
function loadBooks(){
d3.tsv("all_id_codes_title_top25.txt", function(error, data) {
			for (j=0; j<data.length; j++){
				manyBooks.push(data[j].title);
				manyIds.push(data[j].id);
				manyCodes.push(data[j].code);
			}
		})
}

var matchingArray = [];
var matched = [];
function books(incoming, thisCircle){
clicked = 0;
d3.tsv("all_id_codes_title_top25.txt", function(error, data) {
incomingIs = incoming.split(",");
// console.log(incomingIs-1);
//match incoming with corresponding other code
// matchingArray = [1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];

// for (i=0; i<subjCode.length; i++){
// 	for (j=0;j<incomingIs.length; j++){
// 	if (incomingIs[j]==subjCode[i]){
// 		matched.push(matchingArray[i]);
// 	}
// 	}
// }
// console.log(matched);
	// incomingIs[i] = incomingIs[i]-1; 
			for (j=0; j<data.length; j++){
				// for (i=0; i<incomingIs.length; i++){
				if (data[j].code==incomingIs){ 
					console.log(data[j].code+" matching "+incomingIs)
					updateHoverbox(data[j].title, j, data[j].id);
					whichBooks.push(data[j].title);
					saveId.push(data[j].id);
				}
			// }
			}
})
}
//Setup hover box
  hoverbox = d3.select("#hoverbox")
	.attr("class", "hidden");
var updateHoverbox = function(theseBooks, index, whichCode) {
console.log(theseBooks);
// console.log(index+"index");
console.log(whichCode+"whichCode");
var indexIs = index;
   d3.select('#hoverbox')
   .selectAll(".listBooks")
   .data(whichBooks)
		.enter()
		.append("p")
		.attr("class","listBooks")
		.html(function(d){
			return d; //+"<br>"
		})
		.on("click", function(d,i){
			// console.log(d+whichCode+"but which code is only one code and there are multiple books");
			 window.open('http://clio.columbia.edu/catalog/'+saveId[i]+'.html');
		})
	hoverbox.classed("hidden", false); //show the hoverbox
};

function hideBooks(){
			thing = 0;
		index = 0;
	manyIds.length = 0;
hoverbox.selectAll(".listBooks").remove();
hoverbox.classed("hidden", true);
whichBooks.length = 0;
}

</script>
</body>
</html>