<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link href="css/tipsy.css" rel="stylesheet" type="text/css" /> 
	</head>
	<style>
	body{
		font-family: "Geosanslight";
	}
/* Hoverbox */
#hoverbox {
    /*outline:1px solid grey;*/
    width:150px; 
    height:300px; 
    right: 4px; 
    overflow:auto;
    position: fixed;
}
#hoverbox.hidden {
  /*display: none;*/
}
#hoverbox .title {
  fill: white;
  text-transform: uppercase;
}
.listBooks {
	border-bottom: 1px solid lightgray;
    display: block;
    padding:14px;
      cursor: pointer;
}
#hoverbox rect.background {
  fill: black;
  opacity: 0.2;
}
.outText{
	font-size: 12px; font-family:Geosanslight; font-size:12pt; position: absolute; padding: 5px; z-index: 100000; 
	background-color: #000; 
    color: #FFF; max-width: 300px; padding: 5px 8px 4px 8px; text-align: center; 
}
</style>
<script type="text/javascript" src="js/lib/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="js/lib/jquery.tipsy.js"></script>
<script type="text/javascript" src="js/lib/d3.v3.js"></script>
<script type="text/javascript" src="js/lib/jquery.hoverIntent.js"></script>
<body>
	<div id = "hoverbox"></div>
<script type = "text/javascript">

//NEXT THING IS CLICKING TO GET TO THE BOOKS HTML LINK

var freqscale = 5; //size of circles
var  MAX_LEVELS = 10; //number larger than number of levels of circles
var radius_levels = [0, 0, 240, 180, 125, 70, 15, 0, 0, 0]; //how far away from the center each level is
var subradius = 250; 
var MIN_LINE = 3.0; //length of the little ones
var TEXT_PAD_X = 5;
var TEXT_PAD_Y = 2;
var LEGEND_X_MARGIN = 20;
var LEGEND_SCALE = 0.003;

//  Make an array of Subjects
var subjects;
//  Make an array of Connections
var connections;

var bcolor;
var subtext;
var hsubtext;
var concolor;
var hconcolor;
var legendconcolor;
  bcolor = "rgba(0, 0, 0, 255)";
  concolor = "rgba(210, 210, 210, 50)";
  hconcolor = "rgba(210, 210, 210, 100)";
  legendconcolor = "rgba(210, 210, 210, 75)";
  subtext = "rgba(150, 150, 150, 255)";
  hsubtext = "rgba(210, 210, 210, 255)";

var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 1280, //- margin.left - margin.right,
    height = 750; //- margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
.attr("width",width)
.attr("height",height);
    // .attr("width", width + margin.left + margin.right)
    // .attr("height", height*2 + margin.top + margin.bottom);
        // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var subjX=[];
var subjY=[];
var subjText=[];
var sData = [];
var subjCode = [];
var subjTextInside = [];
var subjLoc = [];

// var color = d3.scale.category20c();

var rScale = d3.scale.linear()
  .domain([-7, 7]) 
  .range([-180, 180]);

var freqIs=[];
var item;

var subradius = 300;

var firstLoad = 0;
var tigReggib = 0;
// runInnerCircles();
// runOuterCircles();
function runOuterCircles(){
//BUT HAVING ASYNCHORNOUS PROBLEMS FOR LOADING THE ARRAYS SO IS THERE SOME SORT OF WHEN YOURE FINISHED DO THE OTHER THING THING?
////this works great
d3.tsv("subjects.tsv", function(error, data) {
var jump = Math.PI*2/data.length; //    float jump = TWO_PI/(float)subjTable.getRowCount();
var angle = 0;
// sData.push(data);
var surroundingCircles = svg.selectAll("surroundingPoints")
	.data(data)
	.enter().append("circle")
	.attr("class", "surroundingPoints")
	.attr("cx", function(d,i){
		subjLoc.push(d.loc);
		subjTextInside.push(d.subject);
		subjX.push(width*.5+subradius*Math.cos(jump*(d.loc-1)));
		return width*.5+subradius*Math.cos(jump*(d.loc-1));
		    //   s.pos.x = width*0.5+subradius*cos(jump*(row.getInt("loc") - 1));
      // println(s.pos.x+"s.pos.x");
      // s.pos.y = height*0.5+subradius*sin(jump*(row.getInt("loc") - 1));

		// return subjX[i];
	})
	.attr("cy", function(d,i){  
	subjY.push(height*.5+subradius*Math.sin(jump*(d.loc-1))); 
			return height*.5+subradius*Math.sin(jump*(d.loc-1));
		// return subjY[i]; 
	})
	.attr("r", 2)
	.attr("opacity",.5)
	.attr("fill", function(d,i){
		if (d.loc<=6){
			return "teal";
		}
		if (d.loc>6&&d.loc<=10){
			return "lightgreen";
		}
		if (d.loc>10&&d.loc<=15){
			return "lightblue";
		}
		if (d.loc>15&&d.loc<21){
			return "blue";
		}
	})
	.on("mouseover", function(d){
		item = d.subjCode;
	})
	.on("mouseout", function(d){
		removeLines();
	});
var surroundingCircles = svg.selectAll("surroundingCircles")
	.data(data)
	.enter().append("circle")
	.attr("class", function(d,i){
		 subjCode.push(d.subjCode);
		return "surroundingCircles";
	})
	.attr("cx", function(d,i){
		return subjX[i];
	})
	.attr("cy", function(d,i){   
		return subjY[i]; 
	})
	.attr("r", function(d){ 
	freqIs.push(d.freq);
		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill","white")
	.attr("opacity",.1)
	.attr("stroke-width",.5)
	// .attr("opacity",.5)
	.on("mouseover", function(d){
		item = d.subjCode;
		d3.select(this)
		.attr("stroke", function(d,i){
			if (d.loc<=6){
				return "teal";
			}
			if (d.loc>6&&d.loc<=10){
				return "lightgreen";
			}
			if (d.loc>10&&d.loc<=15){
				return "lightblue";
			}
			if (d.loc>15&&d.loc<21){
				return "blue";
			}
		})
		.attr("stroke-width",2)
		.attr("opacity", .5);
	})
	.on("mouseout", function(d){
		removeLines();
		d3.select(this)
		.attr("stroke", "none")
		// .attr("stroke-width",1)
		// .attr("opacity", .5);
	});
$('.surroundingCircles').hoverIntent({
    over: function(){
		runLines(item);
	// persistLines();
    },
    out: function(){
		removeLines();
    }
  })

var text = svg.selectAll("text")
	.data(data)
	.enter().append("text")
	.attr("class","outText")
	.attr("x", function(d,i){ 
		if (subjX[i]>width/2){
				return subjX[i]; 	
		}
		else {
			return subjX[i]-d.subject.length*7;
		}
	})
	.attr("y", function(d,i){ 
		return subjY[i];
	})
	// .text(function(d,i) { 
	// 	return d.subject; 
	// })
	.attr("fill",function(d,i){
		if (d.loc<=6){
			return "teal";
		}
		if (d.loc>6&&d.loc<=10){
			return "lightgreen";
		}
		if (d.loc>10&&d.loc<=15){
			return "lightblue";
		}
		if (d.loc>15&&d.loc<21){
			return "blue";
		}
	});

$('.surroundingCircles').tipsy({ 
        gravity: 'nw', 
        html: true, 
        title: function() {
          var d = this.__data__;
          return d.subject+" ("+d.freq+")";

        }
});
})
}

var angles = [];
var r = [];
var calcX=[];
var calcY=[];
var radiusIs = [];
var allCodes = [];	
var temp = [];
var thisThing;
var whatRadius = [];
var myVar;
var firstLoadVar;
var secondLoadVar;
var ready = 0;
// prepData();
// function prepData(){
firstLoadVar = setInterval(function(){ 
	if (firstLoad<300){
	d3.tsv("connectionfreqcodes.txt", function(error, cData) {
	firstLoad++; 
	// console.log();
	storeInnerSubjs(cData[firstLoad].codeName, firstLoad);
	})
	}
	else {
	runOnce();
		clearInterval(firstLoadVar);
		// ready = 1;
		// console.log("false")
	}
	},1);
function runOnce(){
	runInnerCircles();
	runOuterCircles();	
}
// secondLoadVar = setInterval(function(){
// 	runInnerCircles();
// 	runOuterCircles();
// },1);
// if (ready==1){
// 		// console.log("run");
// 			// ready = true;
// 	clearInterval(firstLoadVar);
// }
// })	
// }
// if (ready==1){
// 	console.log("run");
// 	runInnerCircles();
// 	runOuterCircles();
// }



function runInnerCircles(){

d3.tsv("connectionfreqcodes.txt", function(error, cData) {
var counters = [0,0,146,106,33,14,2,0,0,0];
var jumps;

for (i = 0; i < MAX_LEVELS;i++) {
    jumps = Math.PI*2/parseFloat(counters[i]);  
}
for (i = 0; i < cData.length;i++) {
	allCodes.push(cData[i].codeName);
	angles.push(cData[i].angles);
	radiusIs.push(cData[i].radiusIs);
}
for (i=0; i<allCodes.length; i++){
	r.push(allCodes[i].split(","));
}

var inCircle = svg.selectAll("inCircle")
	.data(cData)
	.enter().append("circle")
	.attr("class", "inCircle")
	.attr("cx", function(d,i){
		// subjLoc.push(d.loc);
		// subjTextInside.push(d.subject);
		calcX.push(width*0.5+d.radiusIs*Math.cos(d.angles));
     	return width*0.5+d.radiusIs*Math.cos(d.angles);
	})
	.attr("cy", function(d){ 
		calcY.push(height*0.5+d.radiusIs*Math.sin(d.angles));
		return height*0.5+d.radiusIs*Math.sin(d.angles);
	})
	.attr("r", function(d){
		whatRadius.push(Math.log(d.freq+2.0)*freqscale/2);
		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill", "grey")
	.attr("opacity",.1)
	.on("click", function(d,i){
		clicked = true;
		d3.select(this)
		// .attr("stroke", "darkgray")
		// .attr("stroke-width",2)
		.attr("opacity", .9);
		thing = d.codeName;
		index = i;
		allOut(thing, index);
		books(thing, index);
		// runLinesOut(d.codeName, i);
		// books(d.codeName,i);
	})
	.on("mouseout", function(d,i){ 
	// 	d3.select(this)
	// 	.attr("stroke","none")
	// 	.attr("stroke-width",1)
	// .attr("opacity",.3)
	// 	thing = d.codeName;
	// 	index = i;


		// removeOutwardLines(d.codeName, i);
		// hideBooks();
	});

	// .on("mouseover", function(d){
	// 	item = d.subjCode;
	// })
	// .on("mouseout", function(d){
	// 	removeLines();
	// });
$('.inCircle').hoverIntent({
    over: function(){
		// allOut(thing, index);
		// books(thing, index);

		// runLines(item);
	// persistLines();
    },
    out: function(){
		// removeOutwardLines(thing, index);
		// hideBooks();
    }
  })
makeGlyph();    

function makeGlyph(){
	// console.log("make glyph");
	myVar = setInterval(function(){ 
	if (tigReggib<300){
			tigReggib++; 
						// console.log(tigReggib+"tigReggib");
	runLinesOut(cData[tigReggib].codeName, tigReggib);
	}
	else {
	}
	},1);
if (tigReggib>=300){
	// console.log("stop");
	clearInterval(myVar);
}
}
})
}

var thisIs = [];
var otherThis = [];
var storeLengths = [];
var thisCircle;
function storeInnerSubjs(arrayOfSubjs, index){
otherThis = arrayOfSubjs.split(",");
		storeLengths.push(otherThis.length);
}

function removeLines(){
	svg.selectAll(".linesIn") //could be just .remove()
	.transition()
	.attr("stroke-opacity",.07)
	.attr("stroke-width",.2);
}


function runLines(passSubjNum){
console.log(passSubjNum+"passed");
var thisNum = passSubjNum-1;

var linesInG = svg.selectAll("linesIn")
    .data(r)
    .enter()
    .append("line")
    .attr("transform", function(d,i){
    	return "translate(" + (calcX[i]) + "," + (calcY[i]) + ")";
	})
    .attr("class", "linesIn")
	.attr("x1",0)
	.attr("y1",0)
	.attr("x2",function(d,i){
		for (j=0; j<allCodes[i].length; j++){
			if (thisNum==d[j]-1){
				return subjX[thisNum]-calcX[i];
			}		
		}
	})
	.attr("y2",function(d,i){
		for (j=0; j<allCodes[i].length; j++){
			if (thisNum==d[j]-1){
				return subjY[thisNum]-calcY[i];
			}		
		}
	})
	.attr("stroke",function(d,i){
		var whichLoc;
		for (j=0; j<allCodes[i].length; j++){
			if (thisNum==d[j]-1){
				whichLoc = subjLoc[thisNum];
				// return subjY[thisNum]-calcY[i];
				if (whichLoc<=6){
					return "teal";
				}
				if (whichLoc>6&&whichLoc<=10){
					return "lightgreen";
				}
				if (whichLoc>10&&whichLoc<=15){
					return "lightblue";
				}
				if (whichLoc>15&&whichLoc<21){
					return "blue";
				}		
			}		
		}
	})
	.attr("stroke-opacity",1)
	.attr("stroke-width",2);
}
function runLinesOut(arrayOfSubjs, index){

thisIs = arrayOfSubjs.split(",");
	// for (i=0; i<thisIs.length; i++){
		// console.log(i+"ARRAY LENGTH")
	// }
thisCircle = index;
var justOne = thisIs[0];
var grabIt = [];
var newG = svg.selectAll("linesOut")
    .data(thisIs)
    .enter()
    .append("line")
    .attr("transform", function(d,i){
    	return "translate(" + (calcX[thisCircle]) + "," + (calcY[thisCircle]) + ")";
	})
    .attr("class", "hey"+thisCircle)//"linesOut")
    .attr("x1", 0)
    .attr("y1",0)
	.attr("x2",0)
	.attr("y2",0)
//OPTION 1
	// .attr("x2",function(d,i){
	// 	console.log(d);
	// 		for (k=0; k<subjCode.length; k++){
	// 			if (k==d){
	// 				console.log(subjTextInside[k-1]+"subjText");
	// 				return subjX[k-1]-calcX[thisCircle];
	// 			}
	// 		}
	// })
	// .attr("y2",function(d,i){
	// 		for (k=0; k<subjCode.length; k++){
	// 			if (k==d){
	// 				return subjY[k-1]-calcY[thisCircle];
	// 			}
	// 		}
	// 	})
	.attr("stroke",function(d,i){
		var whichLoc;
			for (k=0; k<subjCode.length; k++){
				if (k==d){
				whichLoc = subjLoc[k-1];
				if (whichLoc<=6){
					return "teal";
				}
				if (whichLoc>6&&whichLoc<=10){
					return "lightgreen";
				}
				if (whichLoc>10&&whichLoc<=15){
					return "lightblue";
				}
				if (whichLoc>15&&whichLoc<21){
					return "blue";
				}	
			}	
		}
	})
	.attr("stroke-width",1);
	d3.selectAll("line.hey"+thisCircle)
		.transition()
		.attr("x2",function(d){
			// console.log("removing"+d);
				for (k=0; k<subjCode.length; k++){
					if (k==d){
						return (subjX[k-1]-calcX[thisCircle])/(300/whatRadius[thisCircle]);
					}
				}
		})
		.attr("y2",function(d){
				for (k=0; k<subjCode.length; k++){
					if (k==d){
						return (subjY[k-1]-calcY[thisCircle])/(300/whatRadius[thisCircle]);
					}
				}
		})
// var outToText = svg.selectAll("outText") //not outText
//     .data(thisIs)
//     .enter()
// 	.append("text")
// 	.attr("class","outText")
// 	// .attr("class","outText")
// 	.attr("x", function(d,i){ 
// 			for (k=0; k<subjCode.length; k++){
// 				if (k==d){
// 					console.log(subjTextInside[k-1]+"subjText");
// 					return subjX[k-1];
// 				}
// 			}
// 		})
// 	.attr("y", function(d,i){ 
// 			for (k=0; k<subjCode.length; k++){
// 				if (k==d){
// 					// console.log(subjTextInside[k-1]+"subjText");
// 					return subjY[k-1];
// 				}
// 			}
// 		})
// 	.text(function(d,i){ 
// 			for (k=0; k<subjCode.length; k++){
// 				if (k==d){
// 					// console.log(subjTextInside[k-1]+"subjText");
// 					return subjTextInside[k-1]+" "+freqIs[k-1];
// 				}
// 			}
// 		})
// 	.attr("fill","black");
}

function allOut(arrayOfSubjs, index){

thisIs = arrayOfSubjs.split(",");

	// for (i=0; i<thisIs.length; i++){
		// console.log(i+"ARRAY")
	// }
thisCircle = index;
var justOne = thisIs[0];
var grabIt = [];
var newG = svg.selectAll("linesOut")
    .data(thisIs)
    .enter()
    .append("line")
    .attr("transform", function(d,i){
    	return "translate(" + (calcX[thisCircle]) + "," + (calcY[thisCircle]) + ")";
	})
    .attr("class", "hey"+thisCircle)//"linesOut")
    .attr("x1", 0)
    .attr("y1",0)
	.attr("x2",function(d,i){
		// console.log(d);
			for (k=0; k<subjCode.length; k++){
				if (k==d){
					console.log(subjTextInside[k-1]+"subjText");
					return subjX[k-1]-calcX[thisCircle];
				}
			}
	})
	.attr("y2",function(d,i){
			for (k=0; k<subjCode.length; k++){
				if (k==d){
					return subjY[k-1]-calcY[thisCircle];
				}
			}
		})
	.attr("stroke",function(d,i){
		var whichLoc;
			for (k=0; k<subjCode.length; k++){
				if (k==d){
				whichLoc = subjLoc[k-1];
				if (whichLoc<=6){
					return "teal";
				}
				if (whichLoc>6&&whichLoc<=10){
					return "lightgreen";
				}
				if (whichLoc>10&&whichLoc<=15){
					return "lightblue";
				}
				if (whichLoc>15&&whichLoc<21){
					return "blue";
				}	
			}	
		}
	})
	.attr("stroke-width",1);
var outToText = svg.selectAll("outText") //not outText
    .data(thisIs)
    .enter()
	.append("text")
	.attr("class","outText")
	// .attr("class","outText")
	.attr("x", function(d,i){ 
			for (k=0; k<subjCode.length; k++){
				if (k==d){
					console.log(subjTextInside[k-1]+"subjText");
					return subjX[k-1];
				}
			}
		})
	.attr("y", function(d,i){ 
			for (k=0; k<subjCode.length; k++){
				if (k==d){
					// console.log(subjTextInside[k-1]+"subjText");
					return subjY[k-1];
				}
			}
		})
	.text(function(d,i){ 
			for (k=0; k<subjCode.length; k++){
				if (k==d){
					// console.log(subjTextInside[k-1]+"subjText");
					return subjTextInside[k-1]+" "+freqIs[k-1];
				}
			}
		})
	.attr("fill","black");
}
function removeOutwardLines(codes, thisCirc){
	var outToText = svg.selectAll("outText") //not outText
d3.selectAll(".outText").remove();
console.log(thisCirc+"thisCirc");
		d3.selectAll(".hey"+thisCirc) //associated lines
		.transition()
		.attr("x2",function(d){
			// console.log("removing"+d);
				for (k=0; k<subjCode.length; k++){
					if (k==d){
						return (subjX[k-1]-calcX[thisCirc])/(300/whatRadius[thisCirc]);
					}
				}
		})
		.attr("y2",function(d){
				for (k=0; k<subjCode.length; k++){
					if (k==d){
						return (subjY[k-1]-calcY[thisCirc])/(300/whatRadius[thisCirc]);
					}
				}
		})
}

var incomingIs = [];
var whichBooks = [];
var manyBooks = [];
var manyIds = [];
var saveId = [];
loadBooks();
function loadBooks(){
d3.tsv("all_id_codes_title.txt", function(error, data) {
			for (j=0; j<data.length; j++){
				manyBooks.push(data[j].title);
				manyIds.push(data[j].id);
			}
		})
}
function books(incoming, thisCircle){

d3.tsv("all_id_codes_title.txt", function(error, data) {
// console.log(data[0].code);
incomingIs = incoming.split(",");
// console.log(incomingIs);
// console.log(data.length)
			for (j=0; j<data.length; j++){
				// manyBooks.push(data[j].title);
				// manyIds.push(data[j].id);
				if (data[j].code==incomingIs){ 
					updateHoverbox(data[j].title, j, data[j].id);
					whichBooks.push(data[j].title);
					saveId.push(data[j].id);
				}
			}
})
}
//Setup hover box
  hoverbox = d3.select("#hoverbox")
    .attr("class", "hidden");
var updateHoverbox = function(theseBooks, index, whichCode) {
console.log(theseBooks);
console.log(index+"index");
console.log(whichCode+"whichCode");

var indexIs = index;
   d3.select('#hoverbox')
   .selectAll(".listBooks")
   .data(whichBooks)
        .enter()
        .append("p")
        .attr("class","listBooks")
        .html(function(d){
        	console.log(d);
        	return d; //+"<br>"
        })
        .on("click", function(d,i){
        	console.log(d+whichCode+"but which code is only one code and there are multiple books");
        	 window.open('http://clio.columbia.edu/catalog/'+saveId[i]+'.html');
        })
    hoverbox.classed("hidden", false); //show the hoverbox
};

function hideBooks(){
	manyIds.length = 0;
hoverbox.selectAll(".listBooks").remove();
hoverbox.classed("hidden", true);
whichBooks.length = 0;
}
function persistLines(){
var otherLines = svg.selectAll("otherLines")
    .data(r)
    .enter()
    .append("line")
    .attr("transform", function(d,i){
    	return "translate(" + (calcX[i]) + "," + (calcY[i]) + ")";
	})
    .attr("class", "persist")
	//CAN I NORMALIZE THESE USING A JAVASCRIPT FUNCTION? MATH.NORMALIZE?
	.attr("x1",0)
	.attr("y1",0)
	.attr("x2",	function(d,i){
		for (j=0; j<allCodes[i].length; j++){
			for (k=0; k<subjCode.length; k++){
			if (k==d[j]-1){
				return (subjX[k]-calcX[i]);
			}		
		}
		}
	})
	.attr("y2",function(d,i){
		for (j=0; j<allCodes[i].length; j++){
			for (k=0; k<subjCode.length; k++){
			if (k==d[j]-1){
				return (subjY[k]-calcY[i]);
			}		
		}
		}
	})
	.attr("stroke",function(d,i){
		var whichLoc;
		for (j=0; j<allCodes[i].length; j++){
			for (k=0; k<subjCode.length; k++){
			if (k==d[j]-1){
				whichLoc = subjLoc[k];
				if (whichLoc<=6){
					return "teal";
				}
				if (whichLoc>6&&whichLoc<=10){
					return "lightgreen";
				}
				if (whichLoc>10&&whichLoc<=15){
					return "lightblue";
				}
				if (whichLoc>15&&whichLoc<21){
					return "blue";
				}		
			}		
		}
	}
	})
	.attr("stroke-opacity", .07)
	.attr("stroke-width",.2);
}
</script>
</body>
</html>