<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link href="css/tipsy.css" rel="stylesheet" type="text/css" /> 
	</head>
	<style>
	body{
		font-family: "Geosanslight";
	}
	</style>
<script type="text/javascript" src="js/lib/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="js/lib/jquery.tipsy.js"></script>
<script type="text/javascript" src="js/lib/d3.v3.js"></script>
<script type="text/javascript" src="js/lib/jquery.hoverIntent.js"></script>
<body>
<script type = "text/javascript">
var freqscale = 5; //size of circles
var  MAX_LEVELS = 10; //number larger than number of levels of circles
var radius_levels = [0, 0, 240, 180, 125, 70, 15, 0, 0, 0]; //how far away from the center each level is
var subradius = 250; 
var MIN_LINE = 3.0; //length of the little ones
var TEXT_PAD_X = 5;
var TEXT_PAD_Y = 2;
var LEGEND_X_MARGIN = 20;
var LEGEND_SCALE = 0.003;

//  Make an array of Subjects
var subjects;
//  Make an array of Connections
var connections;

var bcolor;
var subtext;
var hsubtext;
var concolor;
var hconcolor;
var legendconcolor;
  bcolor = "rgba(0, 0, 0, 255)";
  concolor = "rgba(210, 210, 210, 50)";
  hconcolor = "rgba(210, 210, 210, 100)";
  legendconcolor = "rgba(210, 210, 210, 75)";
  subtext = "rgba(150, 150, 150, 255)";
  hsubtext = "rgba(210, 210, 210, 255)";

var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 1280, //- margin.left - margin.right,
    height = 750; //- margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
.attr("width",width)
.attr("height",height);
    // .attr("width", width + margin.left + margin.right)
    // .attr("height", height*2 + margin.top + margin.bottom);
        // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var subjX=[];
var subjY=[];
var subjText=[];
var sData = [];
var subjCode = [];
var subjTextInside = [];
var subjLoc = [];

// var color = d3.scale.category20c();

var rScale = d3.scale.linear()
  .domain([-7, 7]) 
  .range([-180, 180]);

var freqIs=[];
var item;

function runOuterCircles(){
//BUT HAVING ASYNCHORNOUS PROBLEMS FOR LOADING THE ARRAYS SO IS THERE SOME SORT OF WHEN YOURE FINISHED DO THE OTHER THING THING?
////this works great
d3.tsv("subjects.tsv", function(error, data) {
var jump = Math.PI*2/data.length;
var angle = 0;
sData.push(data);

var surroundingCircles = svg.selectAll("surroundingCircles")
	.data(data)
	.enter().append("circle")
	.attr("class", function(d,i){
		 subjCode.push(d.subjCode);
		return "surroundingCircles";
	})
	.attr("cx", function(d,i){
		return subjX[i];
	})
	.attr("cy", function(d,i){   
		return subjY[i]; 
	})
	.attr("r", function(d){ 
	freqIs.push(d.freq);
		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill", function(d,i){
		if (d.loc<=5){
			return "teal";
		}
		if (d.loc>5&&d.loc<=10){
			return "lightgreen";
		}
		if (d.loc>10&&d.loc<=15){
			return "lightblue";
		}
		if (d.loc>15&&d.loc<21){
			return "blue";
		}
    // return "rgb(0, " + (d.subjCode * 10) + ", " + (d.subjCode * 30) + ")";
		// return "hsl("+subjCode[i]*5+",1,1)";
		// return color(d.subjCode);
	})
	// .attr("opacity",.5)
	.on("mouseover", function(d){
		item = d.subjCode;
	})
	.on("mouseout", function(d){
		removeLines();
	});
$('.surroundingCircles').hoverIntent({
    over: function(){
		runLines(item);
    },
    out: function(){
		removeLines();
    }
  })

var text = svg.selectAll("text")
	.data(data)
	.enter().append("text")
	.attr("x", function(d,i){ 
		return subjX[i]-40; 
	})
	.attr("y", function(d,i){ 
		return subjY[i];
	})
	.text(function(d,i) { 
		return d.subjCode+"code "+d.loc+"loc"; 
	})
	.attr("fill","black");

// var surroundingLines = svg.selectAll("surroundingLines")
// 	.data(data)
// 	.enter().append("line")
// 	.attr("class", "surroundingLines")
// 	.attr("x1", function(d,i){
//   		// return i*50;
//   		// console.log(Math.cos(jump*(d.loc - 1)));
//   	// subjX.push(width*0.5+subradius*2.3*Math.cos(jump*(d.loc - 1)));	
//      // return width*0.5+subradius*2.3*Math.cos(jump*(d.loc - 1));
// 		return subjX[i]; 
// 	})
// 	.attr("y1", function(d,i){   
// 		// return height/2;
// 	// subjY.push(height*0.5+subradius*2.3*Math.sin(jump*(d.loc - 1)));
//      // return height*0.5+subradius*2.3*Math.sin(jump*(d.loc - 1));
// 		return subjY[i]; 
// 	})
// 	.attr("x2", width/2)
// 	.attr("y2", height/2)
// 	.attr("stroke","black");

$('.surroundingCircles').tipsy({ 
        gravity: 'nw', 
        html: true, 
        title: function() {
          var d = this.__data__;
          return d.subject+" ("+d.freq+")";

        }
});
})
}

var angles = [];
var r = [];
var calcX=[];
var calcY=[];
var codeSubj=[];
var radiusIs = [];
var allCodes = [];	
var temp = [];
var thisThing;
var codesLengths = [];
var whatRadius = [];

function runInnerCircles(){

d3.tsv("connectionfreqcodes.txt", function(error, cData) {
var counters = [0,0,146,106,33,14,2,0,0,0];
var jumps;

for (i = 0; i < MAX_LEVELS;i++) {
    jumps = Math.PI*2/parseFloat(counters[i]);  
}
for (i = 0; i < cData.length;i++) {
// calcX.push(cData[i].xIs);
// calcY.push(cData[i].yIs);
	allCodes.push(cData[i].codeName);
	angles.push(cData[i].angles);
	radiusIs.push(cData[i].radiusIs);
	codesLengths.push(cData[i].q);
}
for (i=0; i<20; i++){
	codeSubj.push(cData[i].codeSubj);
}
for (i=0; i<allCodes.length; i++){
	r.push(allCodes[i].split(","));
}

var inCircle = svg.selectAll("circle")
	.data(cData)
	.enter().append("circle")
	.attr("class", "inCircle")
	.attr("cx", function(d,i){
		subjY.push(Math.round(d.subjY));
		subjX.push(Math.round(d.subjX));
		subjLoc.push(d.loc);
		subjTextInside.push(d.subject);

		// return d.xIs;
		calcX.push(width*0.5+d.radiusIs*Math.cos(d.angles));
     	return width*0.5+d.radiusIs*Math.cos(d.angles);
	})
	.attr("cy", function(d){ 
		calcY.push(height*0.5+d.radiusIs*Math.sin(d.angles));
		return height*0.5+d.radiusIs*Math.sin(d.angles);
	})
	.attr("r", function(d){
		whatRadius.push(Math.log(d.freq+2.0)*freqscale/2);
		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill", "grey")
	.attr("opacity",.3)
	// function(d){
		// return "rgba(20,100,100,.5)";
	// })
	.on("mouseover", function(d,i){
		console.log(d.codeName+"d.codeName from mouse");
		console.log(i+"index from mouse")
		runLinesOut(d.codeName, i);
	})
	.on("mouseout", function(d){ removeLines() });
})
}

runInnerCircles();
runOuterCircles();
// runLines(1);
function removeLines(){
	svg.selectAll("line").remove();
}

// function runLines(passSubjNum){
// console.log(passSubjNum+"passed");
// // var thisNum = passSubjNum-1;
// 	// r.push(allCodes[i].split(","));
// passIt = passSubjNum.split(",");

// var thisNum = passIt[0]-1;
// console.log(passIt[0]+"thisNum");
// 	var normX = d3.scale.linear()
// 	.domain([-width, width])
// 	.range([5,10]);

// var normY = d3.scale.linear()
// 	.domain([-height, height])
// 	.range([5,10]);






function runLines(passSubjNum){
console.log(passSubjNum+"passed");
var thisNum = passSubjNum-1;

var g = svg.selectAll("line")
    .data(r)
    .enter()
    .append("line")
    .attr("transform", function(d,i){
    	return "translate(" + (calcX[i]) + "," + (calcY[i]) + ")";
	})
    .attr("class", function(d,i){
    	 return d;
    })
	//CAN I NORMALIZE THESE USING A JAVASCRIPT FUNCTION? MATH.NORMALIZE?
	.attr("x1",0)
	.attr("y1",0)
	// .attr("x2",	function(d,i){
	// 	for (j=0; j<allCodes[i].length; j++){
	// 		for (k=0; k<subjCode.length; k++){
	// 		if (k==d[j]){
	// 			return (subjX[k]-calcX[i]);
	// 		}		
	// 	}
	// 	}
	// })
	//THIS JUST IDENTIFIES ONE SUBJECT - WORKS WITH THE MOUSEOVER AND PASS ONE NUMBER
	.attr("x2",function(d,i){
		for (j=0; j<allCodes[i].length; j++){
			if (thisNum==d[j]){
				return subjX[thisNum]-calcX[i];
			}		
		}
	})

	.attr("y2",function(d,i){
		for (j=0; j<allCodes[i].length; j++){
			if (thisNum==d[j]){
				return subjY[thisNum]-calcY[i];
			}		
		}
	})
	// .attr("y2",function(d,i){
	// 	for (j=0; j<allCodes[i].length; j++){
	// 		for (k=0; k<subjCode.length; k++){
	// 		if (k==d[j]){
	// 			return (subjY[k]-calcY[i]);
	// 		}		
	// 	}
	// 	}
	// })
	.attr("stroke","black")
	.attr("stroke-width",.5);
}
var thisIs = [];

function runLinesOut(arrayOfSubjs, index){
console.log(arrayOfSubjs+"hi");

thisIs = arrayOfSubjs.split(",");
	for (i=0; i<thisIs.length; i++){
		console.log(i+"ARRAY")
	}
var thisCircle = index;
console.log(thisCircle+"variable for index");
console.log(thisIs[0]+"thisIs")
var justOne = thisIs[0];
var grabIt = [];
var g = svg.selectAll("line")
    .data(thisIs)
    .enter()
    .append("line")
    .attr("transform", function(d,i){
    	return "translate(" + (calcX[thisCircle]) + "," + (calcY[thisCircle]) + ")";
	})
    .attr("class", function(d,i){
    	 return d;
    })
    .attr("x1", 0)
    .attr("x2", 0)
	// .attr("x2",	function(d,i){
	// 	for (j=0; j<allCodes[i].length; j++){
	// 		for (k=0; k<subjCode.length; k++){
	// 		if (k==d[j]){
	// 			return (subjX[k]-calcX[i]);
	// 		}		
	// 	}
	// 	}
	// })
	//THIS JUST IDENTIFIES ONE SUBJECT - WORKS WITH THE MOUSEOVER AND PASS ONE NUMBER
	.attr("x2",function(d,i){
		console.log(d);
		// for (b=0; b<thisIs.length; b++){
				// console.log(thisIs[b]+" b inside x2");
			for (k=0; k<subjCode.length; k++){
			// for (k=0; k<5; k++){
				if (k==d){
					return subjX[k-1]-calcX[thisCircle];
					// grabIt.push(k);
				}
			}
		
			// for (j=0; j<grabIt.length; j++){
			// 	if (i==thisCircle){
			// 		return subjX[grabIt[j]]-calcX[thisCircle];
			// 	}
			// }
	})
	//NEED TO FIGURE OUT A WAY TO DRAW ADDITIONAL LINES 
	//FOR ALL THE ELEMNTS IN THE ARRAY
	//INSTEAD OF JUST THE INDEX NUMBER WE ARE IN
	.attr("y2",function(d,i){
			for (k=0; k<subjCode.length; k++){
				if (k==d){
					return subjY[k-1]-calcY[thisCircle];
				}
			}
		})
		

		// for (b=0; b<thisIs.length; b++){
		// if (i==thisCircle){
		// 		// console.log(b+" b "+thisIs[b]+"thisisatb "+thisIs.length+"thisislength");
		// 	// for (k=0; k<5; k++){
		// 	for (k=0; k<subjCode.length; k++){

		// 		if (k==thisIs[b]){
		// 			return subjY[k]-calcY[thisCircle];									
		// 		}
		// 	}
		// 	}
		// }

	// 		for (j=0; j<grabIt.length; j++){
	// 			if (i==thisCircle){
	// 				return subjY[grabIt[j]]-calcY[thisCircle];
	// 			}
	// 		}
	// })
	.attr("stroke","black")
	.attr("stroke-width",.5);
}

					//////WORKS
					// 		if (i==thisCircle){
					// 	return subjY[justOne-1]-calcY[thisCircle];
					// }
										//////WORKS

			// for (b=0; b<arrayOfSubjs; b++){
						// return subjX[arrayOfSubjs[b]]-calcX[thisCircle];
		// 	}
		// }
		// for (j=0; j<allCodes[i].length; j++){
		// 	if (thisNum==d[j]){
		// 		return subjY[thisNum]-calcY[i];
		// 	}		
		// }

</script>
</body>
</html>