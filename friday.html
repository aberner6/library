<!DOCTYPE html>
<meta charset="utf-8">
<head>
<link href="css/tipsy.css" rel="stylesheet" type="text/css" /> 
	</head>
<script type="text/javascript" src="js/lib/jquery-1.7.2.min.js"></script>
<script type="text/javascript" src="js/lib/jquery.tipsy.js"></script>
<script type="text/javascript" src="js/lib/d3.v3.js"></script>
	<script src="js/lib/vector.js"></script>
<body>
<script type = "text/javascript">
var freqscale = 5; //size of circles
var  MAX_LEVELS = 10; //number larger than number of levels of circles
var radius_levels = [0, 0, 240, 180, 125, 70, 15, 0, 0, 0]; //how far away from the center each level is
var subradius = 250; 
var MIN_LINE = 3.0; //length of the little ones
var TEXT_PAD_X = 5;
var TEXT_PAD_Y = 2;
var LEGEND_X_MARGIN = 20;
var LEGEND_SCALE = 0.003;

//  Make an array of Subjects
var subjects;
//  Make an array of Connections
var connections;

var bcolor;
var subtext;
var hsubtext;
var concolor;
var hconcolor;
var legendconcolor;
  bcolor = "rgba(0, 0, 0, 255)";
  concolor = "rgba(210, 210, 210, 50)";
  hconcolor = "rgba(210, 210, 210, 100)";
  legendconcolor = "rgba(210, 210, 210, 75)";
  subtext = "rgba(150, 150, 150, 255)";
  hsubtext = "rgba(210, 210, 210, 255)";

var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 1280, //- margin.left - margin.right,
    height = 750; //- margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
.attr("width",width)
.attr("height",height);
    // .attr("width", width + margin.left + margin.right)
    // .attr("height", height*2 + margin.top + margin.bottom);
        // .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var subjX=[];
var subjY=[];
var subjText=[];
var sData = [];
var subjCode = [];




var rScale = d3.scale.linear()
  .domain([-7, 7]) 
  .range([-180, 180]);

var freqIs=[];


function runOuterCircles(){
//BUT HAVING ASYNCHORNOUS PROBLEMS FOR LOADING THE ARRAYS SO IS THERE SOME SORT OF WHEN YOURE FINISHED DO THE OTHER THING THING?
////this works great
d3.tsv("subjects.tsv", function(error, data) {
// console.log(data);
var jump = Math.PI*2/data.length;
var angle = 0;
sData.push(data);

var surroundingCircles = svg.selectAll("surroundingCircles")
	.data(data)
	.enter().append("circle")
	.attr("class", "surroundingCircles")
	.attr("cx", function(d,i){
		return subjX[i];
  		// return i*50;
  		// console.log(Math.cos(jump*(d.loc - 1)));
  	subjCode.push(d.subjCode);
  	// subjX.push(width*0.5+subradius*2.3*Math.cos(jump*(d.loc - 1)));	

  	// subjText.push(d.subject);
  	// subjCode.push(d.subjcode);
   //   return width*0.5+subradius*Math.cos(jump*(d.loc - 1));
	})
	.attr("cy", function(d,i){   
		return subjY[i]; 
		// return height/2;

	// subjY.push(height*0.5+subradius*2.3*Math.sin(jump*(d.loc - 1)));
     // return height*0.5+subradius*Math.sin(jump*(d.loc - 1));
	})
	.attr("r", function(d){ 
	freqIs.push(d.freq);
		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill", function(d,i){
		// console.log(subjY[i]);
		return "rgba("+d.loc*20+",100,100,.5)";
	})

var text = svg.selectAll("text")
	.data(data)
	.enter().append("text")
	.attr("x", function(d,i){ 
		return subjX[i]; 
	})
	.attr("y", function(d,i){ 
		return subjY[i];
	})
	.text(function(d,i) { 
		// console.log(subjText[i])
		return d.subjCode+" loc:"+d.loc; 
	})
	.attr("fill","black");

$('.surroundingCircles').tipsy({ 
        gravity: 'nw', 
        html: true, 
        //fade: true,
        title: function() {
          var d = this.__data__;
          // console
          return d.subject+" ("+d.freq+")";
          // var intit = parseInt(d.score);
          // return (intit)+" pts";
        }
});
})
}

function runInnerCircles(){

d3.tsv("connectionfreqcodes.txt", function(error, cData) {
// console.log(cData);
var counters = [0,0,146,106,33,14,2,0,0,0];
var jumps;
var angles = [];
var radiusIs = [];
var q = [];	
var temp = [];
var thisThing;
var r = [];
// var subIx;
for (i = 0; i < MAX_LEVELS;i++) {
    jumps = Math.PI*2/parseFloat(counters[i]);  
}
for (i = 0; i < cData.length;i++) {
	q.push(cData[i].codeName);
	angles.push(cData[i].angles);
	radiusIs.push(cData[i].radiusIs);
}
for (i=0; i<q.length; i++){
	r.push(q[i].split(","));
		// console.log(r.length);
}
// for (t=0; t<q[1].length; q++){
// var c=q[2].split(",")
console.log(r[2].length);
// }
console.log(q[2])
console.log(r[2][3])

console.log(subjX[300]+"does this exist? no - only 20 subjects"); //no because there are only 20 subjects
for (i=2; i<subjX.length; i++){
	// console.log(i-1); //these are the codenames
}
console.log(subjX.length+"thisis subjx length");
console.log(subjText[9]);
var calcX=[];
var calcY=[];





// console.log(q)
		// console.log(q[0].length);
////this works
console.log(cData.length+"cdata length")
var inCircle = svg.selectAll("circle")
	.data(cData)
	.enter().append("circle")
	.attr("class", "inCircle")
	.attr("cx", function(d,i){
		subjY.push(Math.round(d.subjY))
		subjX.push(Math.round(d.subjX))
		// calcX.push(parseInt(d.xIs));
		// return parseInt(d.xIs);
		calcX.push(width*0.5+d.radiusIs*Math.cos(d.angles));
     	return width*0.5+d.radiusIs*Math.cos(d.angles);
		// console.log(d.codeName);
	})
	.attr("cy", function(d){ 
		// calcY.push(parseInt(d.yIs));
		// console.log(d.yIs);
		// return parseInt(d.yIs);
	calcY.push(height*0.5+d.radiusIs*Math.sin(d.angles));
		return height*0.5+d.radiusIs*Math.sin(d.angles);
	})
	.attr("r", function(d){
	// console.log(width*0.5+d.radiusIs*2*Math.cos(d.angles));

		return Math.log(d.freq+2.0)*freqscale/2;
	})
	.attr("fill", function(d){
		return "rgba(20,100,100,.5)";
	});

console.log(calcX.length+"calc x is the problem - <r?");
console.log(r.length);

var g = svg.selectAll("g")
    .data(r)
    .enter()
    .append("g")
 //    .attr("transform", function(d,i){
 //    	// console.log(calcX[i]);
 //    	return "translate(" + (calcX[i]) + "," + (calcY[i]) + ")";
	// })
var newThing=[];

////BEAUTIFUL BUT no direction
// g.selectAll("rect")
//     .data(function(d,i){ 
//     	return d; 
//     })
//     .enter()
//     .append("rect")
//     .attr("x", function(d,i){
//     	return i*4;
//     })
//     .attr("y", function(d){
//     	return 0;
//     })
//     .attr("width", 1)
//     .attr("height",5)
//     .attr("stroke","lightgray");

g.selectAll("line")
    .data(function(d,i){ 
    	return d; 
    })
    .enter()
    .append("line")
    .attr("x1", function(d,i){
		// if (d==17){
		// 	for (t=0;t<r.length; t++){
		// 		return calcX[t];
		// 	}
		// }
    	return width/2;
	})
	.attr("y1", function(d,i){
		// if (d==17){
		// 	for (t=0;t<r.length; t++){
		// 		return calcY[t];
		// 	}
		// }
		return height/2;
	})
	//CAN I NORMALIZE THESE USING A JAVASCRIPT FUNCTION? MATH.NORMALIZE?
// 	var len = Math.sqrt(normal.x * normal.x + normal.y * normal.y)
// normal.x /= len;
// normal.y /= len;
	.attr("x2", function(d,i){
		// console.log(d+" is the data "+d[i]+" but this is what d at i gets")
		// if (d==2){
			// for (t=0;t<r.length; t++){
		// console.log(subjX[17]-calcX[t]);	
			// if(calcX[t]>width/2){
				console.log(subjX[5]+"x"+subjCode+"code"+subjText[5]+"subj")
				return (subjX[5]+width/2);			 									
			// }
			// }
		// }

		// for (b=2; b<calcX.length+1; b++){
		// 		if (d==b){
		// 			if (isNaN(subjX[b])){
		// 				console.log(subjX[b]+"is nan "+d+"d "+b+"b")
		// 			 }
		// 			 if (b==17){
		// 			 	// console.log(calcX.length);
		// 			 	for (j=0; j<calcX.length; j++){
		// 			 	// return (subjX[17]-calcX[j]);	
		// 			 	}
		// 			 }
		// 			 	// return (subjX[b])/50;
		// 	}
		// }
	})
	.attr("y2", function(d,i){
		// if (d==2){
			// return height/2-calc;
			// for (t=0;t<r.length; t++){

				return (subjY[5]+height/2); //-calcY[t]			 					
			// }
		// }
		// for (b=2; b<calcX.length+1; b++){
		// 		if (d==b){
		// 	 		if (b==17){
		// 			 	for (j=0; j<calcX.length; j++){
		// 			 	// return (subjY[17]-calcY[j]);					 		
		// 			 	}
		// 			 }
		// 			// return (subjY[b])/50;
		// 		}
		// 	}
	})
	.attr("stroke","lightgray");
});
}


// ////works ok
// g.selectAll("rect")
//     .data(function(d,i){ 
//     	return d; 
//     })
//     .enter()
//     .append("rect")
//     .attr("x", function(d,i){
//     	return i*5;
// 	})
// 	.attr("y", function(d,i){
// 		return 0;
// 	})
// 	.attr("width", 1)
// 	.attr("height",5)


runInnerCircles();

runOuterCircles();
// runInnerCircles();
// setTimeout(function () { 
//     runOuterCircles();
//     }
// , 4000); 

</script>
</body>
</html>